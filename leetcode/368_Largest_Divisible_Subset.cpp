class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        const int N = nums.size();
        if (N < 2) return nums;

        sort(nums.begin(), nums.end());

        vector<int> maxLens(N, 1);
        unordered_map<int, vector<int>> preTails;

        int len = 0;
        for (int i = 1; i < N; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] % nums[j] == 0) {
                    if (maxLens[j] + 1 == maxLens[i]) {
                        preTails[i].push_back(j);
                    } else if (maxLens[j] + 1 > maxLens[i]) {
                        maxLens[i] = maxLens[j] + 1;
                        preTails[i] = vector<int>(1, j);
                    }
                }
            }
        }

        // find max
        int iMax = 0, nMax = 0;
        for (int i = 0; i < N; ++i) {
            if (maxLens[i] > nMax) {
                iMax = i;
                nMax = maxLens[i];
            }
        }

        // build subset
        vector<int> subset(nMax, 0);
        int i = iMax;
        while (--nMax) {
            subset[nMax] = nums[i];
            i = preTails[i].front();
        }
        subset[0] = nums[i];

        return subset;
    }
};


class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        const int N = nums.size();
        if (N < 2) return nums;

        sort(nums.begin(), nums.end());

        vector<int> maxLen(N, 1);
        vector<int> prevId(N, -1);

        // get max length and previous position index
        for (int i = 1; i < N; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] % nums[j] == 0 && maxLen[i] < maxLen[j] + 1) {
                    maxLen[i] = maxLen[j] + 1;
                    prevId[i] = j;
                }
            }
        }

        // find the max subset length
        int iMax = 0, nMax = 0;
        for (int i = 0; i < N; ++i) {
            if (maxLen[i] > nMax) {
                iMax = i;
                nMax = maxLen[i];
            }
        }

        // build the subset
        vector<int> subset(nMax, 0);
        while (nMax--) {
            subset[nMax] = nums[iMax];
            iMax = prevId[iMax];
        }

        return subset;
    }
};



/**
 * Input:
 * [472,105,328,922,963,625,827,232,913,832,730,152,697,614,570,639,459,895,70,488,239,596,930,402,904,197,911,126,876,535,597,332,863,870,646,839,878,751,528,959,929,679,7,543,248,353,494,67,841,732,662,122,485,565,318,747,42,545,282,638,228,496,860,874,334,556,103,437,83,61,365,761,259,361,64,612,206,131,452,938,144,573,774,243,521,102,787,154,92,15,649,951,240,506,342,770,940,135,700,820,393,412,884,356,618,366,807,907,861,380,32,921,622,23,760,57,466,416,391,273,706,512,212,998,263,279,743,27,514,98,996,231,905,902,91,636,285,364,609,189,738,368,203,846,6,970,210,748,594,268,157,726,257,419,999,797,869,96,792,451,352,693,894,987,978,595,518,346,315,114,900,160,119,721,218,814,988,477,66,733,740,421,537,642,178,882,21,337,868,350,945,815,219,290,129,684,640,155,409,712,372,222,848,765,932,283,14,819,544,146,425,958,644,903,458,473,85,627,845,641,340,198,961,456,992,495,413,170,390,559,143,166,428,100,809,647,354,619,435,250,837,533,530,883,948,816,432,261,623,560,503,406,916,147,826,277,312,253,729,251,434,443,686,683,944,186,829,898,63,457,405,417,811,579,957,404,532,621,8,260,445,45,887,296,728,236,591,447,422,696,481,893,264,974,701,714,379,12,482,541,942,385,849,345,469,705,527,571,799,962,650,387,552,97,808,971,242,803,36,505,777,89,507,52,47,436,703,716,794,229,628,108,800,779,69,449,165,973,897,324,943,689,917,745,76,873,164,616,9,24,237,739,892,818,718,351,617,420,744,314,687,956,782,781,297,424,737,912,522,272,408,369,645,275,611,840,382,125,890,162,568,295,349,301,997,38,908,179,333,439,899,329,65,159,142,121,923,247,854,802,330,335,43,843,254,137,954,515,790,950,566,857,490,822,519,286,150,583,796,291,941,37,742,723,784,976,374,780,888,569,879,805,88,468,463,969,258,877,176,564,654,798,789,793,401,493,557,592,202,418,115,852,462,953,717,338,480,981,396,634,836,681,629,935,553,540,397,665,758,817,224,821,158,968,323,17,3,776,177,81,906,749,344,169,140,926,118,501,927,504,598,875,34,643,548,813,470,508,736,602,378,59,652,994,915,249,213,661,450,39,267,586,55,727,25,113,141,734,972,872,300,516,526,270,112,555,171,766,256,127,10,316,554,194,448,657,847,174,241,620,68,562,426,133,265,491,909,989,168,173,167,928,41,567,986,724,658,208,699,709,306,933,2,653,881,298,750,577,702,319,694,394,601,651,309,16,310,668,486,192,136,33,856,134,563,370,358,498,593,230,484,308,851,235,51,551,536,980,415,810,246,307,79,221,580,576,101,438,791,455,673,75,610,376,44,624,399,294,271,195,725,637,78,773,806,967,163,871,389,453,558,925,193,467,274,371,788,599]
 * Output:
 * [105,7,210,21,420,840]
 * Expected:
 * [3,6,12,24,96,192,576]
 */

class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        if (nums.empty()) return vector<int>();

        vector<vector<int>> subsets;

        bool added = false;
        int i = 0, n = 0;
        for (int v : nums) {
            added = false;
            for (auto& sub : subsets) {
                for (i = 0, n = sub.size(); i < n; ++i) {
                    if (sub[i] % v != 0 && v % sub[i] != 0) break;
                }
                if (i == n) {
                    sub.push_back(v);
                    added = true;
                }
            }
            if (!added) subsets.emplace_back(1, v);
        }

        auto p = subsets.data();
        for (auto& sub : subsets) {
            if (p->size() < sub.size()) p = &sub;
        }

        return *p;
    }
};


/**
 * Input:
 * [832,33,531,416,335,298,365,352,582,936,366,305,930,530,97,349,71,295,840,108,299,804,925,627,953,571,658,732,429,136,563,462,666,330,796,315,695,500,896,982,217,200,912,98,297,612,169,943,628,593,959,904,219,240,857,789,897,940,569,384,502,382,401,184,716,230,29,963,211,597,515,122,163,86,215,105,889,842,49,847,267,87,954,407,245,975,719,746,709,471,281,238,186,510,618,149,73,214,663,194,260,825,631,474,519,668,329,718,765,947,156,353,490,962,679,560,59,387,31,692,976,568,201,273,159,730,819,418,906,801,892,672,559,866,389,675,812,744,164,737,57,195,115,933,158,909,598,359,853,314,983,11,395,153,781,301,838,625,704,256,351,996,225,644,521,509,674,417,272,622,937,723,632,331,228,412,181,435,469,157,368,524,38,132,325,420,127,731,771,604,505,634,67,374,894,3,448,878,686,641,316,207,76,363,795,235,770,446,820,493,177,816,615,410,117,944,829,190,831,289,516,964,170,134,671,885,682,119,402,82,485,901,375,68,858,739,56,974,683,884,815,872,715,104,290,348,588,834,788,472,466,867,550,779,65,802,459,440,870,753,608,808,623,642,44,437,865,758,540,506,691,958,854,546,39,595,369,504,63,311,722,441,786,899,338,651,874,946,811,848,939,284,824,309,653,133,514,460,678,54,399,759,468,61,480,783,266,900,400,237,403,534,213,914,473,198,380,373,288,154,844,535,409,249,285,168,69,345,647,851,846,264,102,246,106,648,576,212,438,981,987,379,360,667,95,172,101,580,891,385,747,161,927,361,818,657,171,342,232,734,714,362,425,475,28,41,551,142,131,51,229,9,607,326,522,687,792,845,665,358,91,720,155,565,99,26,650,539,780,589,950,935,372,227,424,750,833,554,841,552,60,757,430,916,140,790,426,776,96,199,923,806,949,755,711,659,911,611,310,774,265,880,690,706,761,286,255,756,204,444,478,601,529,669,241,784,566,528,208,270,511,236,271,378,58,453,467,233,250,567,296,932,989,367,626,35,162,887,572,603,564,797,280,406,970,689,408,431,638,489,85,50,357,803,47,555,793,422,763,110,869,861,253,320,538,347,405,769,64,875,630,537,328,553,166,948,303,160,800,507,920,922,90,693,636,17,455,183,210,856,762,656,174,873,579,176,688,640,1,938,902,341,740,581,427,111,972,443,22,791,304,574,575,725,477,700,817,381,479,248,121,411,547,182,871,599,203,13,224,541,724,178,775,388,4,251,321,52,88,100,279,614,839,84,151,735,40,752,773,376,77,476,708,396,988,961,24,231,445,609,952,965,986,414,451,881,42,257,32,334,130,596,527,94,333,317,244,960,710,852,862,421,81,37,452,274,187,268,520,491,778,18,743,620,145,72,370,118,748,633,997,436,143,573,495,180,34]
 * Output:
 * [1,3,9,18,54,108,540]
 * Expected:
 * [1,3,9,18,90,180,360,720]
 */
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        if (nums.empty()) return vector<int>();

        sort(nums.begin(), nums.end());

        vector<vector<int>> subsets;
        bool added = false;
        for (auto v : nums) {
            added = false;
            for (auto& sub : subsets) {
                if (v % sub.back() == 0) {
                    sub.push_back(v);
                    added = true;
                }
            }
            if (!added) {
                subsets.emplace_back(1, v);
            }
        }

        auto p = subsets.data();
        for (auto& sub : subsets) {
            if (p->size() < sub.size()) p = &sub;
        }

        return *p;
    }
};
